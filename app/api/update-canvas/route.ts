import { NextRequest, NextResponse } from "next/server";
import fs from "fs";
import path from "path";
import sharp from "sharp";
import OpenAI from "openai";
import { generateStyledPrompt } from "@/lib/prompt-style";
import axios from "axios";

// Initialize OpenAI client
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

export async function POST(req: NextRequest) {
  try {
    const { prompt, style, x, y, previousCanvasUrl } = await req.json();

    if (!prompt || x === undefined || y === undefined) {
      return NextResponse.json(
        { success: false, error: "Prompt, x, and y coordinates are required" },
        { status: 400 }
      );
    }

    const timestamp = Date.now();
    const publicCanvasPath = path.join(process.cwd(), "public", "canvas");
    const publicPixelsPath = path.join(process.cwd(), "public", "pixels");

    // Ensure directories exist
    if (!fs.existsSync(publicCanvasPath)) {
      fs.mkdirSync(publicCanvasPath, { recursive: true });
    }
    if (!fs.existsSync(publicPixelsPath)) {
      fs.mkdirSync(publicPixelsPath, { recursive: true });
    }

    // File paths for canvas and individual pixel
    const canvasFilePath = path.join(
      publicCanvasPath,
      `canvas-${timestamp}.png`
    );
    const pixelFilePath = path.join(
      publicPixelsPath,
      `pixel-${x}-${y}-${timestamp}.png`
    );

    // Canvas dimensions - 1024x1024 with 16x16 grid of 64px cells
    const cellSize = 64;
    const gridSize = 16;
    const canvasWidth = 1024;
    const canvasHeight = 1024;

    // Force generate a new background if none exists
    let baseCanvas;
    const generateNewBackground =
      !previousCanvasUrl || !previousCanvasUrl.startsWith("/canvas/");

    if (!generateNewBackground) {
      const previousPath = path.join(
        process.cwd(),
        "public",
        previousCanvasUrl.replace(/^\//, "")
      );

      if (fs.existsSync(previousPath)) {
        baseCanvas = sharp(previousPath);
        console.log("Using existing canvas:", previousPath);
      } else {
        console.log("Previous canvas not found, generating new background");
        baseCanvas = await createEmptyCanvas(canvasWidth, canvasHeight, prompt);
      }
    } else {
      console.log("Generating new background with prompt:", prompt);
      baseCanvas = await createEmptyCanvas(canvasWidth, canvasHeight, prompt);
    }

    console.log("Saving canvas to:", canvasFilePath);

    let contextPrompt = prompt;
    if (previousCanvasUrl) {
      contextPrompt = `Continue the existing image at coordinates (${x}, ${y}) with: ${prompt}`;
    }

    const pixelImageBuffer = await generatePixelImage(
      contextPrompt,
      style,
      x,
      y,
      previousCanvasUrl
    );

    await sharp(pixelImageBuffer).toFile(pixelFilePath);

    const pixelUrl = `/pixels/pixel-${x}-${y}-${timestamp}.png`;

    const posX = x * cellSize;
    const posY = y * cellSize;

    const resizedPixelBuffer = await sharp(pixelImageBuffer)
      .resize(cellSize, cellSize, {
        fit: "contain",
        position: "center",
      })
      .toBuffer();

    await baseCanvas
      .composite([
        {
          input: resizedPixelBuffer,
          top: posY,
          left: posX,
        },
      ])
      .toFile(canvasFilePath);

    const canvasUrl = `/canvas/canvas-${timestamp}.png`;

    return NextResponse.json({
      success: true,
      message: "Canvas updated successfully",
      canvasUrl,
      pixelUrl,
      coordinates: { x, y },
    });
  } catch (error) {
    console.error("Canvas update failed:", error);
    return NextResponse.json(
      { success: false, error: (error as Error).message },
      { status: 500 }
    );
  }
}

/**
 * Create an empty canvas with background content related to the prompt
 */
async function createEmptyCanvas(
  width: number,
  height: number,
  userPrompt?: string
): Promise<sharp.Sharp> {
  try {
    const backgroundPrompt = userPrompt
      ? `Create a background image containing ${userPrompt}.`
      : "Create a background image with a landscape.";

    console.log("Generating background with prompt:", backgroundPrompt);

    const response = await openai.images.generate({
      model: "gpt-image-1",
      prompt: backgroundPrompt,
      n: 1,
      size: "1024x1024",
    });

    if (!response.data || !response.data[0]) {
      throw new Error("No background image generated by OpenAI");
    }

    // Get image data
    let imageBuffer: Buffer;
    if (response.data[0].url) {
      const imageResponse = await axios.get(response.data[0].url, {
        responseType: "arraybuffer",
      });
      imageBuffer = Buffer.from(imageResponse.data);
    } else if (response.data[0].b64_json) {
      imageBuffer = Buffer.from(response.data[0].b64_json, "base64");
    } else {
      throw new Error("No image data returned from OpenAI");
    }

    return sharp(imageBuffer).modulate({
      brightness: 1.3,
      saturation: 0.4,
    });
  } catch (error) {
    console.error("Failed to create background canvas:", error);

    return sharp({
      create: {
        width,
        height,
        channels: 4,
        background: { r: 252, g: 252, b: 253, alpha: 1 },
      },
    }).composite([
      {
        input: Buffer.from(
          `<svg width="${width}" height="${height}">
            <defs>
              <filter id="noise" x="0%" y="0%" width="100%" height="100%">
                <feTurbulence type="fractalNoise" baseFrequency="0.01" numOctaves="3" result="noise"/>
                <feColorMatrix type="matrix" values="1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0.05 0"/>
              </filter>
              <pattern id="grid" width="64" height="64" patternUnits="userSpaceOnUse">
                <path d="M 64 0 L 0 0 0 64" fill="none" stroke="#f0f0f0" stroke-width="0.5"/>
              </pattern>
            </defs>
            <rect width="100%" height="100%" fill="#fafafa"/>
            <rect width="100%" height="100%" filter="url(#noise)"/>
            <rect width="100%" height="100%" fill="url(#grid)" opacity="0.3"/>
          </svg>`
        ),
        top: 0,
        left: 0,
      },
    ]);
  }
}

/**
 * Generate a pixel image based on the prompt using OpenAI
 */
async function generatePixelImage(
  prompt: string,
  style?: string,
  x?: number,
  y?: number,
  previousCanvasUrl?: string | null
): Promise<Buffer> {
  try {
    // Map style string to expected format
    const styleMap: {
      [key: string]:
        | "pixelArt"
        | "chibi"
        | "kawaiiPastel"
        | "softBlob"
        | "sanrio"
        | "vinylToy"
        | "storybook"
        | "flatDesign"
        | "y2kBubble"
        | "crochetAmigurumi";
    } = {
      "pixel-art": "pixelArt",
      "kawaii-pastel": "kawaiiPastel",
      "soft-blob": "softBlob",
      "vinyl-toy": "vinylToy",
      "flat-design": "flatDesign",
      "y2k-bubble": "y2kBubble",
      "crochet-amigurumi": "crochetAmigurumi",
    };

    // Map style or default to pixelArt if not found
    const mappedStyle = style ? styleMap[style] || "pixelArt" : "pixelArt";

    // Enhanced prompt with stronger continuity instructions
    let enhancedPrompt = prompt;

    if (previousCanvasUrl && x !== undefined && y !== undefined) {
      enhancedPrompt = `Create a pixel art image of: ${prompt}.`;
    } else {
      enhancedPrompt = `Create a vibrant, detailed pixel art image of: ${prompt}.`;
    }

    if (style) {
      enhancedPrompt = generateStyledPrompt(mappedStyle, enhancedPrompt);
    }

    // Generate image using OpenAI
    const response = await openai.images.generate({
      model: "gpt-image-1",
      prompt: enhancedPrompt,
      n: 1,
      size: "1024x1024",
    });

    if (!response.data || !response.data[0]) {
      throw new Error("No image generated by OpenAI");
    }

    // Get image data - either from URL or base64
    let imageBuffer: Buffer;

    if (response.data[0].url) {
      // Download image from URL
      const imageResponse = await axios.get(response.data[0].url, {
        responseType: "arraybuffer",
      });
      imageBuffer = Buffer.from(imageResponse.data);
    } else if (response.data[0].b64_json) {
      // Convert base64 to buffer
      imageBuffer = Buffer.from(response.data[0].b64_json, "base64");
    } else {
      throw new Error("No image data returned from OpenAI");
    }

    return imageBuffer;
  } catch (error) {
    console.error("Error generating pixel image with OpenAI:", error);
    throw error;
  }
}
